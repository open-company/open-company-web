shadow$provide.module$node_modules$$sentry$utils$dist$syncpromise=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var is_1=require("module$node_modules$$sentry$utils$dist$is"),States;(function(States){States.PENDING="PENDING";States.RESOLVED="RESOLVED";States.REJECTED="REJECTED"})(States||(States={}));global=function(){function SyncPromise(executor){var _this=this;this._state=States.PENDING;this._handlers=[];this._resolve=function(value){_this._setResult(States.RESOLVED,
value)};this._reject=function(reason){_this._setResult(States.REJECTED,reason)};this._setResult=function(state,value){_this._state===States.PENDING&&(is_1.isThenable(value)?value.then(_this._resolve,_this._reject):(_this._state=state,_this._value=value,_this._executeHandlers()))};this._attachHandler=function(handler){_this._handlers=_this._handlers.concat(handler);_this._executeHandlers()};this._executeHandlers=function(){if(_this._state!==States.PENDING){var cachedHandlers=_this._handlers.slice();
_this._handlers=[];cachedHandlers.forEach(function(handler){if(!handler.done){if(_this._state===States.RESOLVED&&handler.onfulfilled)handler.onfulfilled(_this._value);if(_this._state===States.REJECTED&&handler.onrejected)handler.onrejected(_this._value);handler.done=!0}})}};try{executor(this._resolve,this._reject)}catch(e){this._reject(e)}}SyncPromise.resolve=function(value){return new SyncPromise(function(resolve){resolve(value)})};SyncPromise.reject=function(reason){return new SyncPromise(function(_,
reject){reject(reason)})};SyncPromise.all=function(collection){return new SyncPromise(function(resolve,reject){if(Array.isArray(collection))if(0===collection.length)resolve([]);else{var counter=collection.length,resolvedCollection=[];collection.forEach(function(item,index){SyncPromise.resolve(item).then(function(value){resolvedCollection[index]=value;--counter;0===counter&&resolve(resolvedCollection)}).then(null,reject)})}else reject(new TypeError("Promise.all requires an array as input."))})};SyncPromise.prototype.then=
function(onfulfilled,onrejected){var _this=this;return new SyncPromise(function(resolve,reject){_this._attachHandler({done:!1,onfulfilled:function(result){if(onfulfilled)try{resolve(onfulfilled(result))}catch(e){reject(e)}else resolve(result)},onrejected:function(reason){if(onrejected)try{resolve(onrejected(reason))}catch(e){reject(e)}else reject(reason)}})})};SyncPromise.prototype.catch=function(onrejected){return this.then(function(val){return val},onrejected)};SyncPromise.prototype.finally=function(onfinally){var _this=
this;return new SyncPromise(function(resolve,reject){var val,isRejected;return _this.then(function(value){isRejected=!1;val=value;onfinally&&onfinally()},function(reason){isRejected=!0;val=reason;onfinally&&onfinally()}).then(function(){isRejected?reject(val):resolve(val)})})};SyncPromise.prototype.toString=function(){return"[object SyncPromise]"};return SyncPromise}();exports.SyncPromise=global}
//# sourceMappingURL=module$node_modules$$sentry$utils$dist$syncpromise.js.map
