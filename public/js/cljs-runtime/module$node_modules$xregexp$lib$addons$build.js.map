{
"version":3,
"file":"module$node_modules$xregexp$lib$addons$build.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/xregexp/lib/addons/build.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$xregexp$lib$addons$build\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n\n/*!\n * XRegExp.build 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * const h12 = /1[0-2]|0?[1-9]/;\n   * const h24 = /2[0-3]|[01][0-9]/;\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n   * const minutes = /^[0-5][0-9]$/;\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce.default)(_context = (0, _map.default)(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map.default)(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _includes.default)(flags).call(flags, 'x');\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat.default)(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","_Object$defineProperty","value","default","_concat","_includes","_map","_reduce","_default","XRegExp","deanchor","pattern","leadingAnchor","trailingAnchor","test","replace","asXRegExp","addFlagX","flags","isRegExp","REGEX_DATA","captureNames","source","interpolate","substitution","RegExp","escape","reduceToSubpatternsObject","subpatterns","interpolated","subpatternIndex","concat","embedSubpatternAfter","raw","rawLiterals","length","subParts","parts","union","conjunction","tag","XRegExp.tag","literals","_context","_context2","_len","arguments","substitutions","Array","_key","call","join","build","XRegExp.build","subs","inlineFlags","exec","_clipDuplicates","data","p","hasOwnProperty","sub","names","patternAsRegex","numCaps","numPriorCaps","numOuterCaps","outerCapsMap","outerCapNames","output","$0","$1","$2","$3","$4","subName","_context3","ReferenceError","capName","intro","rewrittenSubpattern","match","paren","backref","localCapIndex"]
}
