{
"version":3,
"file":"module$node_modules$xregexp$lib$addons$matchrecursive.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/xregexp/lib/addons/matchrecursive.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$xregexp$lib$addons$matchrecursive\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\n/*!\n * XRegExp.matchRecursive 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes.default)(flags).call(flags, 'g');\n    var sticky = (0, _includes.default)(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat.default)(_context = (0, _concat.default)(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice.default)(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice.default)(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice.default)(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice.default)(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","_Object$defineProperty","value","default","_slice","_concat","_includes","_default","XRegExp","row","name","start","end","matchRecursive","XRegExp.matchRecursive","str","left","right","flags","options","call","sticky","basicFlags","replace","escapeChar","vN","valueNames","output","openTokens","delimStart","delimEnd","lastOuterEnd","_context","_context2","length","Error","escape","esc","RegExp","concat","union","conjunction","source","exec","leftMatch","rightMatch","index","outerStart","innerStart","push"]
}
